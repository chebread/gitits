// [3] 여기서 컴포넌트를 클로저로 설정하고 값을 컴포넌트에 묶어서 관리해야 함
// 이거를 아직 모르겠음

// options.routes = window.location.pathname;
// if (
//   !(options.routes === '') &&
//   !(options.routes === window.location.pathname)
// ) {
//   // 라우터가 기존과 변경된다면 값을 없에는 것임 => 편하게 하려면 그냥 라우터가 변경될때마다
//   options.states = [];
//   options.currentStateKey = 0;
//   render();
// }

// console.log(options.currentStateKey); // render를 한후에 0으로 초기화 되서 그나마 작동이 되는 거임 즉 초기화 되는 지점은 0, 1로 초기화를 진행하고 그러고 있는데
// 만약에 0이 안되면 그냥 계속 3, 4 기하 급수적으로 커지고 render를 하여 0으로 가면 그제야 기본 기본 값을 참조하게 됨

// const isDuplicates = new Set(options.states).size != options.states.length; // 이게 그냥 함수만 다시 실행됬다는 증거!
//     if (isDuplicates) {
//       console.log('기존값과 동일한 값이 있어서 초기화가 필요합니다');
//       options.states = [];
//       options.currentStateKey = 0;
//       render();
//     }

// 초기화 한 count 값이 원래 값과 같다면 0으로 만들자
// count값이 원래 값과 같은 값이 주어진다면은? 초기화가 진행되지 않고 그냥 다시 함수를 실행한 것임
// options.states.length 이거는 처음 초기화 빼고는 모두 동일한 값임!!! (init 으로 인식하자!) 어? init을 얼마나 하는지가 그에 따른 전송값의 대한 useState 실행한 횟수값 아닌가?

// 그니까 2를 넘어가면은 그냥 f를 함수를 한번더 실행한거라 이거는 문제가 있으니 그냥 0으로 초기화 한다는 것임
// 최대 유지값 2

// console.log('얼마나 초기화 할까용? 2만 하자제발뤀ㅋㅋ');
// options.count += 1;

//count: 0,
//after: 0,
//basic: 0,

// console.log(`${options.count} -- basic`);
//options.basic = options.count;

// 그저 라우터 변경이 일어난다면 모든 값을 초기화 하자....
// 그저 currney가 0이 아니라면은 0으로 초기화 하면 됨
// 그냥 key만 초기화 하면은 됨 그러면 편함 (동일 라우터로 접속을 원할때)

// count는 useState가 한 컴포넌트에서 얼마나 쓰일건지를 명시하는 값이다
// 그냥 라우터 변경이 감지가 되면 그냥 모든 값을 초기화 하는 그러하게 로직을 구성해야 함

// 이거는 그냥 동일라우터는 처리 못함... ㅠㅠ
// [3] 컴포넌트에 맞게 값을 저장한다면? (states의 저장방법과 currney의 저장방법을 컴포넌트에 맞도록 완전히 바꿔야 함)
// [4] 그리고 컴포넌트에 맞게 값을 보전할 수 있음
// [5] 그러면 일단은 counts를 내부적으로 처리하도록 해야 함 (개어렵네) ** ? 일단은 컴포넌트 내에서 값을 관리하는 것을 중점으로 해야 함 (어려움)

// if (options.path != '' && options.path != window.location.pathname) {
//   // 이 부분을 없에고 컴포넌트의 값 보전으로 바꿔야 함
//   console.log('라우터 변경으로 초기화 진행되었습니다');
//   options.states = [];
//   options.currentStateKey = 0;
//   render();
// }
// options.path = window.location.pathname;
// // [0] 각각의 컴포넌트에서 값을 저장해야 함 * (이게 엄청난 하드 코어... 컴포넌트를 어떻게 분류할 것인가? 왜 하드냐면 컴포넌트에서 또 컴포넌트가 실행되기 때문에..)

// if (options.count === new Set(options.states).size) {
//   console.log(options.count + ' ---sdf');
// }
// const isDuplicates = new Set(options.states).size != options.states.length;
//     if (isDuplicates) {
//       // 같은 값 두번 요청시 없에기 (같은 주소 요청)
//       // 이제 원래 값이 있다면!
//       console.log('duplicate');
//       // options.count += 1;
//       options.currentStateKey = 1;
//       options.states = [options.states[0]]; // 가장 중요한 부분
//     }
//     console.log(isDuplicates, options.currentStateKey, options.states);
